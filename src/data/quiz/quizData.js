// 퀴즈 데이터 - 난이도와 설명 추가
const quizData = [
  // React - 초급
  {
    id: 1,
    category: 'React',
    difficulty: 'beginner',
    question: 'React의 핵심 개념 중 하나로, UI를 독립적이고 재사용 가능한 조각으로 만드는 것을 무엇이라 하나요?',
    options: ['Props', 'State', 'Component', 'Hook'],
    answer: 2,
    explanation: 'Component는 React의 기본 빌딩 블록으로, UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있게 해줍니다.',
  },
  {
    id: 2,
    category: 'React',
    difficulty: 'beginner',
    question: 'React에서 상태 관리를 위해 사용되는 훅은 무엇인가요?',
    options: ['useEffect', 'useState', 'useRef', 'useCallback'],
    answer: 1,
    explanation: 'useState는 함수형 컴포넌트에서 상태(state)를 관리하기 위한 기본 훅입니다.',
  },
  {
    id: 3,
    category: 'React',
    difficulty: 'beginner',
    question: 'React의 JSX 문법에서 여러 요소를 반환할 때 반드시 감싸야 하는 부모 요소는?',
    options: ['<div>', '<span>', '<section>', '<Fragment> 또는 <> </>'],
    answer: 3,
    explanation: 'Fragment(<> </>)는 DOM에 추가 노드를 생성하지 않고 여러 자식을 그룹화할 수 있습니다.',
  },
  {
    id: 4,
    category: 'React',
    difficulty: 'beginner',
    question: '다음 중 React Hook이 아닌 것은?',
    options: ['useEffect', 'useReducer', 'useClass', 'useMemo'],
    answer: 2,
    explanation: 'useClass는 존재하지 않는 훅입니다. React에는 클래스 컴포넌트와 함수형 컴포넌트가 있지만, useClass 훅은 없습니다.',
  },
  {
    id: 5,
    category: 'React',
    difficulty: 'beginner',
    question: '컴포넌트에 전달되는 데이터를 무엇이라 부르나요?',
    options: ['State', 'Props', 'Event', 'Variable'],
    answer: 1,
    explanation: 'Props(Properties)는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 읽기 전용 데이터입니다.',
  },
  // React - 중급
  {
    id: 11,
    category: 'React',
    difficulty: 'intermediate',
    question: 'React에서 컴포넌트가 화면에 처음 나타날 때 실행되는 훅은?',
    options: ['useState', 'useRef', 'useEffect', 'useMemo'],
    answer: 2,
    explanation: 'useEffect에 빈 의존성 배열([])을 전달하면 컴포넌트가 마운트될 때 한 번만 실행됩니다.',
  },
  {
    id: 12,
    category: 'React',
    difficulty: 'intermediate',
    question: 'React의 Props에 대한 설명으로 올바른 것은?',
    options: [
      '컴포넌트 내부에서 직접 수정할 수 있다.',
      '상위 컴포넌트가 하위 컴포넌트에 전달하는 읽기 전용 데이터이다.',
      '렌더링과 무관하다.',
      '값을 변경하면 화면이 갱신되지 않는다.',
    ],
    answer: 1,
    explanation: 'Props는 읽기 전용이며, 데이터의 단방향 흐름을 유지합니다. 자식 컴포넌트에서 props를 직접 수정할 수 없습니다.',
  },
  {
    id: 14,
    category: 'React',
    difficulty: 'intermediate',
    question: 'React의 Virtual DOM의 역할은?',
    options: [
      '사용자의 입력을 관리한다.',
      '변경 사항을 실제 DOM에 직접 반영한다.',
      '변경 사항을 메모리상에서 먼저 계산하고, 실제 DOM과 비교하여 최소한의 변경만 적용한다.',
      '서버 데이터를 관리한다.',
    ],
    answer: 2,
    explanation: 'Virtual DOM은 변경 사항을 메모리에서 먼저 계산한 후 실제 DOM과 비교(diffing)하여 필요한 부분만 업데이트합니다.',
  },
  {
    id: 16,
    category: 'React',
    difficulty: 'intermediate',
    question: 'React에서 컴포넌트 간에 직접 데이터를 전달하지 않고 상태를 공유하기 위해 사용하는 기술은?',
    options: ['useState', 'Context API', 'useEffect', 'useReducer'],
    answer: 1,
    explanation: 'Context API는 prop drilling 없이 컴포넌트 트리 전체에 데이터를 전달할 수 있게 해줍니다.',
  },
  {
    id: 19,
    category: 'React',
    difficulty: 'intermediate',
    question: 'React 앱에서 특정 DOM 요소에 직접 접근할 때 사용하는 훅은?',
    options: ['useState', 'useRef', 'useEffect', 'useMemo'],
    answer: 1,
    explanation: 'useRef는 렌더링 사이에 값을 유지하고, DOM 요소에 직접 접근할 수 있게 해줍니다.',
  },
  {
    id: 20,
    category: 'React',
    difficulty: 'intermediate',
    question: 'React에서 useEffect의 의존성 배열([])에 아무 값도 넣지 않으면 언제 실행되나요?',
    options: ['렌더링 때마다', '초기 렌더링 한 번만', '변수 변경 시', '컴포넌트 언마운트 시'],
    answer: 1,
    explanation: '빈 의존성 배열은 이펙트가 마운트 시 한 번만 실행되고, 언마운트 시 정리 함수가 실행됨을 의미합니다.',
  },
  // React - 고급
  {
    id: 17,
    category: 'React',
    difficulty: 'advanced',
    question: '상태 값이 자주 변경되는 경우, 불필요한 렌더링을 방지하는 훅은?',
    options: ['useCallback', 'useEffect', 'useState', 'useRef'],
    answer: 0,
    explanation: 'useCallback은 함수를 메모이제이션하여 의존성이 변경될 때만 새 함수를 생성합니다. useMemo는 값을 메모이제이션합니다.',
  },
  {
    id: 21,
    category: 'React',
    difficulty: 'advanced',
    question: 'React.memo의 역할은 무엇인가요?',
    options: [
      '컴포넌트의 상태를 메모리에 저장',
      'props가 변경되지 않으면 리렌더링을 방지',
      '이펙트를 메모이제이션',
      '컨텍스트 값을 캐싱',
    ],
    answer: 1,
    explanation: 'React.memo는 고차 컴포넌트로, props가 변경되지 않으면 리렌더링을 건너뛰어 성능을 최적화합니다.',
  },
  {
    id: 22,
    category: 'React',
    difficulty: 'advanced',
    question: 'useReducer를 useState 대신 사용하면 좋은 경우는?',
    options: [
      '단순한 boolean 상태 관리',
      '복잡한 상태 로직이나 다음 상태가 이전 상태에 의존할 때',
      '컴포넌트가 마운트될 때만 상태가 필요할 때',
      'props로 전달받은 값을 상태로 사용할 때',
    ],
    answer: 1,
    explanation: 'useReducer는 복잡한 상태 로직, 여러 하위 값을 포함하는 상태, 또는 다음 상태가 이전 상태에 의존하는 경우에 적합합니다.',
  },
  {
    id: 23,
    category: 'React',
    difficulty: 'advanced',
    question: 'React의 Suspense 컴포넌트의 주요 용도는?',
    options: [
      '에러 경계 처리',
      '비동기 컴포넌트의 로딩 상태 처리',
      '컴포넌트 상태 초기화',
      'DOM 이벤트 처리',
    ],
    answer: 1,
    explanation: 'Suspense는 자식 컴포넌트가 로딩되는 동안 fallback UI를 보여주며, 데이터 페칭이나 코드 스플리팅에 사용됩니다.',
  },
  {
    id: 24,
    category: 'React',
    difficulty: 'advanced',
    question: 'React 18에서 도입된 Concurrent 기능의 장점은?',
    options: [
      '번들 크기 감소',
      '렌더링 작업을 중단하고 재개할 수 있어 UI 응답성 향상',
      '서버 측 렌더링 지원',
      '상태 관리 간소화',
    ],
    answer: 1,
    explanation: 'Concurrent 렌더링을 통해 React는 긴급한 업데이트를 우선 처리하고, 덜 긴급한 업데이트는 나중에 처리할 수 있습니다.',
  },
  // Next.js - 초급
  {
    id: 6,
    category: 'Next.js',
    difficulty: 'beginner',
    question: 'Next.js에서 페이지 기반 라우팅은 어느 폴더 내에 파일을 생성하여 이루어지나요?',
    options: ['/components', '/pages 또는 /app', '/styles', '/public'],
    answer: 1,
    explanation: 'Next.js는 파일 시스템 기반 라우팅을 사용합니다. pages 디렉토리(Pages Router) 또는 app 디렉토리(App Router)에 파일을 생성하면 자동으로 라우트가 됩니다.',
  },
  {
    id: 9,
    category: 'Next.js',
    difficulty: 'beginner',
    question: 'Next.js 프로젝트의 루트에서 글로벌 스타일을 설정할 때 주로 사용하는 파일은?',
    options: ['index.js', '_app.js 또는 layout.js', '_document.js', 'style.css'],
    answer: 1,
    explanation: 'Pages Router에서는 _app.js, App Router에서는 layout.js에서 글로벌 스타일과 레이아웃을 설정합니다.',
  },
  {
    id: 13,
    category: 'Next.js',
    difficulty: 'beginner',
    question: 'Next.js에서 이미지 최적화를 위해 사용하는 기본 컴포넌트는?',
    options: ['<Image>', '<img>', '<Picture>', '<OptimizedImage>'],
    answer: 0,
    explanation: 'next/image의 Image 컴포넌트는 자동 이미지 최적화, 지연 로딩, WebP 변환 등을 제공합니다.',
  },
  {
    id: 18,
    category: 'Next.js',
    difficulty: 'beginner',
    question: 'Next.js에서 동적 라우트를 만들 때 사용하는 파일 이름 규칙은?',
    options: ['[id].js', '{id}.js', '<id>.js', '(id).js'],
    answer: 0,
    explanation: '대괄호를 사용하여 동적 세그먼트를 정의합니다. [id].js는 /posts/1, /posts/2 등의 경로를 처리합니다.',
  },
  // Next.js - 중급
  {
    id: 7,
    category: 'Next.js',
    difficulty: 'intermediate',
    question: 'Next.js의 정적 생성(Static Generation)을 할 때 데이터를 가져오기 위해 사용하는 함수는?',
    options: ['getServerSideProps', 'getStaticProps', 'getInitialProps', 'useEffect'],
    answer: 1,
    explanation: 'getStaticProps는 빌드 시 데이터를 가져와 정적 페이지를 생성합니다. App Router에서는 기본적으로 서버 컴포넌트에서 직접 fetch를 사용합니다.',
  },
  {
    id: 8,
    category: 'Next.js',
    difficulty: 'intermediate',
    question: 'Next.js에서 SSR(Server Side Rendering)을 하기 위해 사용하는 함수는?',
    options: ['getServerSideProps', 'getStaticPaths', 'useState', 'getStaticProps'],
    answer: 0,
    explanation: 'getServerSideProps는 매 요청마다 서버에서 데이터를 가져와 페이지를 렌더링합니다.',
  },
  {
    id: 10,
    category: 'Next.js',
    difficulty: 'intermediate',
    question: 'Next.js에서 정적 경로를 사전에 정의하기 위해 사용하는 함수는?',
    options: ['getStaticPaths', 'getStaticProps', 'getServerSideProps', 'getPaths'],
    answer: 0,
    explanation: 'getStaticPaths는 동적 라우트에서 정적 생성할 경로 목록을 지정합니다. App Router에서는 generateStaticParams를 사용합니다.',
  },
  {
    id: 15,
    category: 'Next.js',
    difficulty: 'intermediate',
    question: 'Next.js에서 API 라우트를 만들 때 파일을 생성하는 폴더는?',
    options: ['/pages', '/components', '/pages/api 또는 /app/api', '/api'],
    answer: 2,
    explanation: 'Pages Router에서는 /pages/api, App Router에서는 /app/api 폴더에 route.js 파일을 생성합니다.',
  },
  // Next.js - 고급
  {
    id: 25,
    category: 'Next.js',
    difficulty: 'advanced',
    question: 'Next.js App Router에서 "use server" 지시어의 역할은?',
    options: [
      '클라이언트 컴포넌트 정의',
      'Server Actions 정의',
      '정적 페이지 생성',
      '미들웨어 설정',
    ],
    answer: 1,
    explanation: '"use server"는 서버에서만 실행되는 Server Actions를 정의합니다. 폼 제출, 데이터 변경 등에 사용됩니다.',
  },
  {
    id: 26,
    category: 'Next.js',
    difficulty: 'advanced',
    question: 'Next.js의 middleware.js 파일의 역할은?',
    options: [
      'API 엔드포인트 정의',
      '요청이 완료되기 전에 코드를 실행하여 요청/응답 수정',
      '정적 파일 서빙',
      '에러 페이지 처리',
    ],
    answer: 1,
    explanation: '미들웨어는 요청이 완료되기 전에 실행되어 인증, 리다이렉트, 헤더 수정 등을 처리합니다.',
  },
  {
    id: 27,
    category: 'Next.js',
    difficulty: 'advanced',
    question: 'Next.js의 revalidatePath와 revalidateTag의 차이점은?',
    options: [
      '둘 다 같은 기능',
      'revalidatePath는 경로 기반, revalidateTag는 태그 기반 캐시 무효화',
      'revalidatePath는 서버용, revalidateTag는 클라이언트용',
      'revalidatePath는 정적 페이지용, revalidateTag는 동적 페이지용',
    ],
    answer: 1,
    explanation: 'revalidatePath는 특정 경로의 캐시를, revalidateTag는 특정 태그가 붙은 모든 데이터의 캐시를 무효화합니다.',
  },
  {
    id: 28,
    category: 'Next.js',
    difficulty: 'advanced',
    question: 'Next.js에서 Streaming과 Suspense를 함께 사용하면 어떤 이점이 있나요?',
    options: [
      '번들 크기 감소',
      '페이지의 일부를 점진적으로 렌더링하여 TTFB 개선',
      '정적 페이지 생성 속도 향상',
      '클라이언트 측 하이드레이션 제거',
    ],
    answer: 1,
    explanation: 'Streaming을 사용하면 서버에서 HTML을 점진적으로 전송하여, 느린 데이터 소스가 전체 페이지를 차단하지 않습니다.',
  },
  {
    id: 29,
    category: 'Next.js',
    difficulty: 'advanced',
    question: 'Next.js App Router에서 parallel routes의 용도는?',
    options: [
      '여러 페이지를 동시에 로드',
      '같은 레이아웃 내에서 여러 페이지를 동시에 또는 조건부로 렌더링',
      'API 병렬 호출',
      '코드 스플리팅 최적화',
    ],
    answer: 1,
    explanation: 'Parallel routes(@folder)를 사용하면 모달, 대시보드 등에서 여러 페이지를 같은 레이아웃에서 동시에 렌더링할 수 있습니다.',
  },
  {
    id: 30,
    category: 'Next.js',
    difficulty: 'advanced',
    question: 'Next.js의 ISR(Incremental Static Regeneration)의 장점은?',
    options: [
      '빌드 시간 단축',
      '정적 페이지를 백그라운드에서 재생성하여 최신 데이터 유지',
      '서버 비용 절감',
      '클라이언트 사이드 라우팅 개선',
    ],
    answer: 1,
    explanation: 'ISR을 사용하면 전체 사이트를 다시 빌드하지 않고도 정적 페이지를 백그라운드에서 재생성하여 최신 상태로 유지할 수 있습니다.',
  },
];

// 난이도별 라벨
export const difficultyLabels = {
  beginner: { label: '초급', color: 'green' },
  intermediate: { label: '중급', color: 'yellow' },
  advanced: { label: '고급', color: 'red' },
};

// 카테고리 목록
export const categories = ['All', 'React', 'Next.js'];

// 난이도 목록
export const difficulties = ['All', 'beginner', 'intermediate', 'advanced'];

export default quizData;
